/* eslint-disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

/**
 * Performs a "dry run" on an RFQ, returning the estimated fee and whether the trade is expected to pass.<br /><br />Should any exception be raised in the process of evaluating the trade, a standard RPC error will be returned<br />with the error details.
 * Required minimum session key permission level is `read_only`
 */
export type PrivateRfqGetBestQuote = PrivateRfqGetBestQuoteJSONRPCSchema;
export type HttpMethod = "POST";
export type Method = "private/rfq_get_best_quote";
/**
 * Optional list of market maker account addresses to request quotes from. If not supplied, all market makers who are approved as RFQ makers will be notified.
 */
export type Counterparties = Counterparties1[] | null;
export type Counterparties1 = string;
/**
 * Planned execution direction (default `buy`)
 */
export type Direction = "buy" | "sell";
/**
 * Optional user-defined label for the RFQ
 */
export type Label = string;
/**
 * Amount in units of the base
 */
export type Amount = string;
/**
 * Leg direction
 */
export type Direction1 = "buy" | "sell";
/**
 * Instrument name
 */
export type InstrumentName = string;
/**
 * RFQ legs
 */
export type Legs = LegUnpricedSchema[];
/**
 * An optional max total cost for the RFQ. Only used when the RFQ sender executes as buyer. Polling endpoints and channels will ignore quotes where the total cost across all legs is above this value. Positive values mean the RFQ sender expects to pay $, negative mean the RFQ sender expects to receive $.This field is not disclosed to the market makers.
 */
export type MaxTotalCost = string | null;
/**
 * An optional min total cost for the RFQ. Only used when the RFQ sender executes as seller. Polling endpoints and channels will ignore quotes where the total cost across all legs is below this value. Positive values mean the RFQ sender expects to receive $, negative mean the RFQ sender expects to pay $.This field is not disclosed to the market makers.
 */
export type MinTotalCost = string | null;
/**
 * RFQ ID to get best quote for. If not provided, will return estimates based on mark prices
 */
export type RfqId = string | null;
/**
 * Subaccount ID
 */
export type SubaccountId = number;
/**
 * Cancel reason, if any
 */
export type CancelReason =
  | ""
  | "user_request"
  | "insufficient_margin"
  | "signed_max_fee_too_low"
  | "mmp_trigger"
  | "cancel_on_disconnect"
  | "session_key_deregistered"
  | "subaccount_withdrawn"
  | "rfq_no_longer_open"
  | "compliance";
/**
 * Creation timestamp in ms since Unix epoch
 */
export type CreationTimestamp = number;
/**
 * Quote direction
 */
export type Direction2 = "buy" | "sell";
/**
 * Last update timestamp in ms since Unix epoch
 */
export type LastUpdateTimestamp = number;
/**
 * Amount in units of the base
 */
export type Amount1 = string;
/**
 * Leg direction
 */
export type Direction3 = "buy" | "sell";
/**
 * Instrument name
 */
export type InstrumentName1 = string;
/**
 * Leg price
 */
export type Price = string;
/**
 * Quote legs
 */
export type Legs1 = LegPricedSchema[];
/**
 * Hash of the legs of the best quote to be signed by the taker.
 */
export type LegsHash = string;
/**
 * Liquidity role
 */
export type LiquidityRole = "maker" | "taker";
/**
 * Quote ID
 */
export type QuoteId = string;
/**
 * RFQ ID
 */
export type RfqId1 = string;
/**
 * Status
 */
export type Status = "open" | "filled" | "cancelled" | "expired";
/**
 * Subaccount ID
 */
export type SubaccountId1 = number;
/**
 * Blockchain transaction hash (only for executed quotes)
 */
export type TxHash = string | null;
/**
 * Blockchain transaction status (only for executed quotes)
 */
export type TxStatus = ("requested" | "pending" | "settled" | "reverted" | "ignored" | "timed_out") | null;
/**
 * Wallet address of the quote sender
 */
export type Wallet = string;
/**
 * Liquidation price if the trade were to be filled and the market moves down.
 */
export type DownLiquidationPrice = string | null;
/**
 * An estimate for how much the user will pay in fees ($ for the whole trade).
 */
export type EstimatedFee = string;
/**
 * An estimate for the realized PnL of the trade.
 */
export type EstimatedRealizedPnl = string;
/**
 * An estimate for the realized PnL of the trade. with cost basis calculated without considering fees.
 */
export type EstimatedRealizedPnlExclFees = string;
/**
 * An estimate for the total $ cost of the trade.
 */
export type EstimatedTotalCost = string;
/**
 * Reason for the RFQ being invalid, if any.
 */
export type InvalidReason =
  | (
      | "Account is currently under maintenance margin requirements, trading is frozen."
      | "This order would cause account to fall under maintenance margin requirements."
      | "Insufficient buying power, only a single risk-reducing open order is allowed."
      | "Insufficient buying power, consider reducing order size."
      | "Insufficient buying power, consider reducing order size or canceling other orders."
      | "Consider canceling other limit orders or using IOC, FOK, or market orders. This order is risk-reducing, but if filled with other open orders, buying power might be insufficient."
      | "Insufficient buying power."
    )
  | null;
/**
 * `True` if RFQ is expected to pass margin requirements.
 */
export type IsValid = boolean;
/**
 * User's hypothetical margin balance if the trade were to get executed.
 */
export type PostInitialMargin = string;
/**
 * Liquidation price if the trade were to be filled. If both upside and downside liquidation prices exist, returns the closest one to the current index price.
 */
export type PostLiquidationPrice = string | null;
/**
 * User's initial margin balance before the trade.
 */
export type PreInitialMargin = string;
/**
 * Recommended value for `max_fee` of the trade.
 */
export type SuggestedMaxFee = string;
/**
 * Liquidation price if the trade were to be filled and the market moves up.
 */
export type UpLiquidationPrice = string | null;

export interface PrivateRfqGetBestQuoteJSONRPCSchema {
  request: PrivateRfqGetBestQuoteRequestSchema;
  response: PrivateRfqGetBestQuoteResponseSchema;
}
export interface PrivateRfqGetBestQuoteRequestSchema {
  httpMethod: HttpMethod;
  id?: string | number;
  method: Method;
  params: PrivateRfqGetBestQuoteParamsSchema;
}
export interface PrivateRfqGetBestQuoteParamsSchema {
  counterparties?: Counterparties;
  direction?: Direction;
  label?: Label;
  legs: Legs;
  max_total_cost?: MaxTotalCost;
  min_total_cost?: MinTotalCost;
  rfq_id?: RfqId;
  subaccount_id: SubaccountId;
}
export interface LegUnpricedSchema {
  amount: Amount;
  direction: Direction1;
  instrument_name: InstrumentName;
}
export interface PrivateRfqGetBestQuoteResponseSchema {
  id: string | number;
  result: PrivateRfqGetBestQuoteResultSchema;
}
export interface PrivateRfqGetBestQuoteResultSchema {
  /**
   * Best quote for the RFQ (or null if RFQ is not created yet or quotes do not exist). This object should be used to sign a taker quote and call into `execute_quote` RPC.
   */
  best_quote: QuoteResultPublicSchema | null;
  down_liquidation_price: DownLiquidationPrice;
  estimated_fee: EstimatedFee;
  estimated_realized_pnl: EstimatedRealizedPnl;
  estimated_realized_pnl_excl_fees: EstimatedRealizedPnlExclFees;
  estimated_total_cost: EstimatedTotalCost;
  invalid_reason: InvalidReason;
  is_valid: IsValid;
  post_initial_margin: PostInitialMargin;
  post_liquidation_price: PostLiquidationPrice;
  pre_initial_margin: PreInitialMargin;
  suggested_max_fee: SuggestedMaxFee;
  up_liquidation_price: UpLiquidationPrice;
}
/**
 * Best quote for the RFQ (or null if RFQ is not created yet or quotes do not exist). This object should be used to sign a taker quote and call into `execute_quote` RPC.
 */
export interface QuoteResultPublicSchema {
  cancel_reason: CancelReason;
  creation_timestamp: CreationTimestamp;
  direction: Direction2;
  last_update_timestamp: LastUpdateTimestamp;
  legs: Legs1;
  legs_hash: LegsHash;
  liquidity_role: LiquidityRole;
  quote_id: QuoteId;
  rfq_id: RfqId1;
  status: Status;
  subaccount_id: SubaccountId1;
  tx_hash: TxHash;
  tx_status: TxStatus;
  wallet: Wallet;
}
export interface LegPricedSchema {
  amount: Amount1;
  direction: Direction3;
  instrument_name: InstrumentName1;
  price: Price;
}
