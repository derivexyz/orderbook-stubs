/* eslint-disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

/**
 * Transfers multiple positions from one subaccount to another, owned by the same wallet.<br /><br />The transfer is executed as a an RFQ. A mock RFQ is first created from the taker parameters, followed by a maker quote and a taker execute.<br />The leg amounts, prices and instrument name must be the same in both param payloads.<br />Fee is not charged and a zero `max_fee` must be signed.<br />Every leg in the transfer must be a position reduction for either maker or taker (or both).<br /><br />History: for position transfer history, use the `private/get_trade_history` RPC (not `private/get_erc20_transfer_history`).
 * Required minimum session key permission level is `admin`
 */
export type PrivateTransferPositions = PrivateTransferPositionsJSONRPCSchema;
export type HttpMethod = "POST";
export type Method = "private/transfer_positions";
/**
 * Quote direction, `buy` means trading each leg at its direction, `sell` means trading each leg in the opposite direction.
 */
export type Direction = "buy" | "sell";
/**
 * Amount in units of the base
 */
export type Amount = string;
/**
 * Leg direction
 */
export type Direction1 = "buy" | "sell";
/**
 * Instrument name
 */
export type InstrumentName = string;
/**
 * Leg price
 */
export type Price = string;
/**
 * Quote legs
 */
export type Legs = LegPricedSchema[];
/**
 * Max fee ($ for the full trade). Request will be rejected if the supplied max fee is below the estimated fee for this trade.
 */
export type MaxFee = string;
/**
 * Unique nonce defined as a concatenated `UTC timestamp in ms` and `random number up to 6 digits` (e.g. 1695836058725001, where 001 is the random number)
 */
export type Nonce = number;
/**
 * Ethereum signature of the quote
 */
export type Signature = string;
/**
 * Unix timestamp in seconds. Expiry MUST be at least 310 seconds from now. Once time till signature expiry reaches 300 seconds, the quote will be considered expired. This buffer is meant to ensure the trade can settle on chain in case of a blockchain congestion.
 */
export type SignatureExpirySec = number;
/**
 * Owner wallet address or registered session key that signed the quote
 */
export type Signer = string;
/**
 * Subaccount ID
 */
export type SubaccountId = number;
/**
 * Public key (wallet) of the account
 */
export type Wallet = string;
/**
 * Cancel reason, if any
 */
export type CancelReason =
  | ""
  | "user_request"
  | "insufficient_margin"
  | "signed_max_fee_too_low"
  | "mmp_trigger"
  | "cancel_on_disconnect"
  | "session_key_deregistered"
  | "subaccount_withdrawn"
  | "rfq_no_longer_open"
  | "compliance";
/**
 * Creation timestamp in ms since Unix epoch
 */
export type CreationTimestamp = number;
/**
 * Quote direction
 */
export type Direction2 = "buy" | "sell";
/**
 * Fee paid for this quote (if executed)
 */
export type Fee = string;
/**
 * Whether the order was generated through `private/transfer_position`
 */
export type IsTransfer = boolean;
/**
 * User-defined label, if any
 */
export type Label = string;
/**
 * Last update timestamp in ms since Unix epoch
 */
export type LastUpdateTimestamp = number;
/**
 * Quote legs
 */
export type Legs1 = LegPricedSchema1[];
/**
 * Hash of the legs of the best quote to be signed by the taker.
 */
export type LegsHash = string;
/**
 * Liquidity role
 */
export type LiquidityRole = "maker" | "taker";
/**
 * Signed max fee
 */
export type MaxFee1 = string;
/**
 * Whether the quote is tagged for market maker protections (default false)
 */
export type Mmp = boolean;
/**
 * Nonce
 */
export type Nonce1 = number;
/**
 * Quote ID
 */
export type QuoteId = string;
/**
 * RFQ ID
 */
export type RfqId = string;
/**
 * Ethereum signature of the quote
 */
export type Signature1 = string;
/**
 * Unix timestamp in seconds
 */
export type SignatureExpirySec1 = number;
/**
 * Owner wallet address or registered session key that signed the quote
 */
export type Signer1 = string;
/**
 * Status
 */
export type Status = "open" | "filled" | "cancelled" | "expired";
/**
 * Subaccount ID
 */
export type SubaccountId1 = number;
/**
 * Blockchain transaction hash (only for executed quotes)
 */
export type TxHash = string | null;
/**
 * Blockchain transaction status (only for executed quotes)
 */
export type TxStatus = ("requested" | "pending" | "settled" | "reverted" | "ignored" | "timed_out") | null;

export interface PrivateTransferPositionsJSONRPCSchema {
  request: PrivateTransferPositionsRequestSchema;
  response: PrivateTransferPositionsResponseSchema;
}
export interface PrivateTransferPositionsRequestSchema {
  httpMethod: HttpMethod;
  id?: string | number;
  method: Method;
  params: PrivateTransferPositionsParamsSchema;
}
export interface PrivateTransferPositionsParamsSchema {
  maker_params: SignedQuoteParamsSchema;
  taker_params: SignedQuoteParamsSchema1;
  wallet: Wallet;
}
/**
 * Maker quote parameters and signature
 */
export interface SignedQuoteParamsSchema {
  direction: Direction;
  legs: Legs;
  max_fee: MaxFee;
  nonce: Nonce;
  signature: Signature;
  signature_expiry_sec: SignatureExpirySec;
  signer: Signer;
  subaccount_id: SubaccountId;
}
export interface LegPricedSchema {
  amount: Amount;
  direction: Direction1;
  instrument_name: InstrumentName;
  price: Price;
}
/**
 * Taker quote execution parameters and signature
 */
export interface SignedQuoteParamsSchema1 {
  direction: Direction;
  legs: Legs;
  max_fee: MaxFee;
  nonce: Nonce;
  signature: Signature;
  signature_expiry_sec: SignatureExpirySec;
  signer: Signer;
  subaccount_id: SubaccountId;
}
export interface PrivateTransferPositionsResponseSchema {
  id: string | number;
  result: PrivateTransferPositionsResultSchema;
}
export interface PrivateTransferPositionsResultSchema {
  maker_quote: QuoteResultSchema;
  taker_quote: QuoteResultSchema1;
}
/**
 * Created maker-side quote object
 */
export interface QuoteResultSchema {
  cancel_reason: CancelReason;
  creation_timestamp: CreationTimestamp;
  direction: Direction2;
  fee: Fee;
  is_transfer: IsTransfer;
  label: Label;
  last_update_timestamp: LastUpdateTimestamp;
  legs: Legs1;
  legs_hash: LegsHash;
  liquidity_role: LiquidityRole;
  max_fee: MaxFee1;
  mmp: Mmp;
  nonce: Nonce1;
  quote_id: QuoteId;
  rfq_id: RfqId;
  signature: Signature1;
  signature_expiry_sec: SignatureExpirySec1;
  signer: Signer1;
  status: Status;
  subaccount_id: SubaccountId1;
  tx_hash: TxHash;
  tx_status: TxStatus;
}
export interface LegPricedSchema1 {
  amount: Amount;
  direction: Direction1;
  instrument_name: InstrumentName;
  price: Price;
}
/**
 * Created taker-side quote object
 */
export interface QuoteResultSchema1 {
  cancel_reason: CancelReason;
  creation_timestamp: CreationTimestamp;
  direction: Direction2;
  fee: Fee;
  is_transfer: IsTransfer;
  label: Label;
  last_update_timestamp: LastUpdateTimestamp;
  legs: Legs1;
  legs_hash: LegsHash;
  liquidity_role: LiquidityRole;
  max_fee: MaxFee1;
  mmp: Mmp;
  nonce: Nonce1;
  quote_id: QuoteId;
  rfq_id: RfqId;
  signature: Signature1;
  signature_expiry_sec: SignatureExpirySec1;
  signer: Signer1;
  status: Status;
  subaccount_id: SubaccountId1;
  tx_hash: TxHash;
  tx_status: TxStatus;
}
