/* eslint-disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

/**
 * Executes a quote.
 * Required minimum session key permission level is `admin`
 */
export type PrivateExecuteQuote = PrivateExecuteQuoteJSONRPCSchema;
export type HttpMethod = "POST";
export type Method = "private/execute_quote";
/**
 * Quote direction, `buy` means trading each leg at its direction, `sell` means trading each leg in the opposite direction.
 */
export type Direction = "buy" | "sell";
/**
 * Optional user-defined label for the quote
 */
export type Label = string;
/**
 * Amount in units of the base
 */
export type Amount = string;
/**
 * Leg direction
 */
export type Direction1 = "buy" | "sell";
/**
 * Instrument name
 */
export type InstrumentName = string;
/**
 * Leg price
 */
export type Price = string;
/**
 * Quote legs
 */
export type Legs = LegPricedSchema[];
/**
 * Max fee ($ for the full trade). Request will be rejected if the supplied max fee is below the estimated fee for this trade.
 */
export type MaxFee = string;
/**
 * Unique nonce defined as a concatenated `UTC timestamp in ms` and `random number up to 6 digits` (e.g. 1695836058725001, where 001 is the random number)
 */
export type Nonce = number;
/**
 * Quote ID to execute against
 */
export type QuoteId = string;
/**
 * RFQ ID to execute (must be sent by `subaccount_id`)
 */
export type RfqId = string;
/**
 * Ethereum signature of the quote
 */
export type Signature = string;
/**
 * Unix timestamp in seconds. Expiry MUST be at least 310 seconds from now. Once time till signature expiry reaches 300 seconds, the quote will be considered expired. This buffer is meant to ensure the trade can settle on chain in case of a blockchain congestion.
 */
export type SignatureExpirySec = number;
/**
 * Owner wallet address or registered session key that signed the quote
 */
export type Signer = string;
/**
 * Subaccount ID
 */
export type SubaccountId = number;
/**
 * Cancel reason, if any
 */
export type CancelReason =
  | ""
  | "user_request"
  | "insufficient_margin"
  | "signed_max_fee_too_low"
  | "mmp_trigger"
  | "cancel_on_disconnect"
  | "session_key_deregistered"
  | "subaccount_withdrawn"
  | "rfq_no_longer_open"
  | "compliance";
/**
 * Creation timestamp in ms since Unix epoch
 */
export type CreationTimestamp = number;
/**
 * Quote direction
 */
export type Direction2 = "buy" | "sell";
/**
 * Fee paid for this quote (if executed)
 */
export type Fee = string;
/**
 * Whether the order was generated through `private/transfer_position`
 */
export type IsTransfer = boolean;
/**
 * User-defined label, if any
 */
export type Label1 = string;
/**
 * Last update timestamp in ms since Unix epoch
 */
export type LastUpdateTimestamp = number;
/**
 * Quote legs
 */
export type Legs1 = LegPricedSchema1[];
/**
 * Hash of the legs of the best quote to be signed by the taker.
 */
export type LegsHash = string;
/**
 * Liquidity role
 */
export type LiquidityRole = "maker" | "taker";
/**
 * Signed max fee
 */
export type MaxFee1 = string;
/**
 * Whether the quote is tagged for market maker protections (default false)
 */
export type Mmp = boolean;
/**
 * Nonce
 */
export type Nonce1 = number;
/**
 * Quote ID
 */
export type QuoteId1 = string;
/**
 * RFQ ID
 */
export type RfqId1 = string;
/**
 * Ethereum signature of the quote
 */
export type Signature1 = string;
/**
 * Unix timestamp in seconds
 */
export type SignatureExpirySec1 = number;
/**
 * Owner wallet address or registered session key that signed the quote
 */
export type Signer1 = string;
/**
 * Status
 */
export type Status = "open" | "filled" | "cancelled" | "expired";
/**
 * Subaccount ID
 */
export type SubaccountId1 = number;
/**
 * Blockchain transaction hash (only for executed quotes)
 */
export type TxHash = string | null;
/**
 * Blockchain transaction status (only for executed quotes)
 */
export type TxStatus = ("requested" | "pending" | "settled" | "reverted" | "ignored" | "timed_out") | null;

export interface PrivateExecuteQuoteJSONRPCSchema {
  request: PrivateExecuteQuoteRequestSchema;
  response: PrivateExecuteQuoteResponseSchema;
}
export interface PrivateExecuteQuoteRequestSchema {
  httpMethod: HttpMethod;
  id?: string | number;
  method: Method;
  params: PrivateExecuteQuoteParamsSchema;
}
export interface PrivateExecuteQuoteParamsSchema {
  direction: Direction;
  label?: Label;
  legs: Legs;
  max_fee: MaxFee;
  nonce: Nonce;
  quote_id: QuoteId;
  rfq_id: RfqId;
  signature: Signature;
  signature_expiry_sec: SignatureExpirySec;
  signer: Signer;
  subaccount_id: SubaccountId;
}
export interface LegPricedSchema {
  amount: Amount;
  direction: Direction1;
  instrument_name: InstrumentName;
  price: Price;
}
export interface PrivateExecuteQuoteResponseSchema {
  id: string | number;
  result: PrivateExecuteQuoteResultSchema;
}
export interface PrivateExecuteQuoteResultSchema {
  cancel_reason: CancelReason;
  creation_timestamp: CreationTimestamp;
  direction: Direction2;
  fee: Fee;
  is_transfer: IsTransfer;
  label: Label1;
  last_update_timestamp: LastUpdateTimestamp;
  legs: Legs1;
  legs_hash: LegsHash;
  liquidity_role: LiquidityRole;
  max_fee: MaxFee1;
  mmp: Mmp;
  nonce: Nonce1;
  quote_id: QuoteId1;
  rfq_id: RfqId1;
  signature: Signature1;
  signature_expiry_sec: SignatureExpirySec1;
  signer: Signer1;
  status: Status;
  subaccount_id: SubaccountId1;
  tx_hash: TxHash;
  tx_status: TxStatus;
}
export interface LegPricedSchema1 {
  amount: Amount;
  direction: Direction1;
  instrument_name: InstrumentName;
  price: Price;
}
